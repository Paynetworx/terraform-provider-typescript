package typescript

import (
	"github.com/hashicorp/terraform/helper/schema"
	"bytes"
	"context"
	"archive/zip"
	"io/ioutil"
	"os"
	"io"
	"fmt"
	"path"
	"path/filepath"
	"io/fs"
	"strings"
	"math/rand"
	"crypto/md5"
	"crypto/sha1"
	"crypto/sha256"
	"encoding/base64"
	"encoding/hex"
	"github.com/docker/docker/api/types"
	"github.com/docker/docker/api/types/mount"
	"github.com/docker/docker/api/types/container"
	"github.com/docker/docker/client"
)

func resourceTypescriptNodeModules() *schema.Resource {
	return &schema.Resource{
		Create: resourceTypescriptNodeModulesCreate,
		Read:   resourceTypescriptNodeModulesRead,
		Delete: resourceTypescriptNodeModulesDelete,

		Schema: map[string]*schema.Schema{
			"source": {
				Type:        schema.TypeString,
				Description: "Absolut paths to source package.json",
				Required:    true,
				ForceNew:    true,
			},
			"triggers":{
				Type:        schema.TypeMap,
				Description: "Map of arbitrary strings to trigger a rebuild",
				Optional:    true,
				ForceNew:    true,
			},
			"output_md5": {
				Type:        schema.TypeString,
				Description: "base64 encoded zip file of generated code",
				Computed:    true,
			},
			"output_sha": {
				Type:        schema.TypeString,
				Description: "base64 encoded zip file of generated code",
				Computed:    true,
			},
			"output_base64sha256": {
				Type:        schema.TypeString,
				Description: "base64 encoded zip file of generated code",
				Computed:    true,
			},
			"output_content_base64": {
				Type:        schema.TypeString,
				Description: "base64 encoded zip file of generated code",
				Computed:    true,
			},
			"build_docker_image":{
				Type:		 schema.TypeString,
				Description: "docker image to use",
				Required:	 true,
				ForceNew:	 true,
			},
			"output_file":{
				Type:        schema.TypeString,
				Description: "path to outputed file",
				Computed:    true,
			},
		},
	}
}


func resourceTypescriptNodeModulesCreate(d *schema.ResourceData, meta interface{}) error {
	source := d.Get("source").(string)
	build_docker_image := d.Get("build_docker_image").(string)

	working_dir, err := ioutil.TempDir("","*")
	if err != nil {
		return err
	}
	output_file, err := ioutil.TempFile("","lambda_node_modules.zip")
	d.Set("output_file",output_file)
	if err != nil {
		return err
	}
	defer os.RemoveAll(working_dir)
	source_file, err := os.Open(source)
	if err != nil {
		return err
	}
	dest_file, err := os.Create(path.Join(working_dir,"package.json"))
	if err != nil {
		return err
	}
	_, err = io.Copy(dest_file, source_file)
	if err != nil {
		return err
	}

	ctx := context.Background()
	cli, err := client.NewClientWithOpts(client.FromEnv, client.WithAPIVersionNegotiation())
	if err != nil {
		return err
	}

	reader, err := cli.ImagePull(ctx, build_docker_image, types.ImagePullOptions{})
	if err != nil {
		return err
	}
	defer reader.Close()

	resp, err := cli.ContainerCreate(ctx, &container.Config{
		Image: build_docker_image,
		Tty:   false,
		Entrypoint: []string{"/bin/bash","-c","npm install"},
		WorkingDir: "/var/task/layer",
	}, &container.HostConfig{
		Mounts: []mount.Mount{
			{
				Type: mount.TypeBind,
				Source: working_dir,
				Target: "/var/task/layer",
			},
		},
	}, nil, nil, "")
	if err != nil {
		return err
	}

	if err := cli.ContainerStart(ctx, resp.ID, types.ContainerStartOptions{}); err != nil {
		return err
	}
	statusCh, errCh := cli.ContainerWait(ctx, resp.ID, container.WaitConditionNotRunning)
	select {
	case err := <-errCh:
		if err != nil {
			return err
		}
	case <-statusCh:
	}

	_, err = cli.ContainerLogs(ctx, resp.ID, types.ContainerLogsOptions{ShowStdout: true})
	if err != nil {
		return err
	}

	err = cli.ContainerRemove(ctx,resp.ID,types.ContainerRemoveOptions{})
	if err != nil {
		return err
	}
	out := bytes.Buffer{}	
	zip := zip.NewWriter(&out)

	err = filepath.Walk(working_dir, func(path string, info fs.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if !info.IsDir() {
			filename := strings.Replace(path,fmt.Sprint(working_dir,"/"),"nodejs/",1)
			contents, err := os.Open(path)
			if err != nil {
				return err
			}
			writer, err := zip.Create(filename)	
			if err != nil {
				return err
			}
			io.Copy(writer, contents)
		}
		return nil
	})
	zip.Close()
	data:= out.Bytes()

	h := sha1.New()
	h.Write(data)
	sha1 := hex.EncodeToString(h.Sum(nil))
	d.Set("output_sha",sha1)

	h256 := sha256.New()
	h256.Write(data)

	shaSum := h256.Sum(nil)
	sha256base64 := base64.StdEncoding.EncodeToString(shaSum[:])
	d.Set("output_base64sha256",sha256base64)

	md5 := md5.New()
	md5.Write(data)
	md5Sum := hex.EncodeToString(md5.Sum(nil))
	d.Set("output_md5",md5Sum)

	io.Copy(output_file,bytes.NewBuffer(data))

	if err != nil {
		return err
	}
	
	d.SetId(fmt.Sprintf("%d", rand.Int()))
	return nil
}

func resourceTypescriptNodeModulesRead(d *schema.ResourceData, meta interface{}) error {
	return nil
}

func resourceTypescriptNodeModulesDelete(d *schema.ResourceData, _ interface{}) error {
	d.SetId("")
	return nil
}
